<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/DATABASE_SCHEMA_CHANGES.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DATABASE_SCHEMA_CHANGES.md" />
              <option name="updatedContent" value="# Cambios en el Schema de la Base de Datos&#10;&#10;## Problema Identificado&#10;&#10;Los `streamId` y `seriesId` se repetían en varias categorías, causando conflictos en la base de datos ya que estaban definidos como claves primarias únicas.&#10;&#10;### Ejemplo del Problema:&#10;```&#10;Stream ID: &quot;12345&quot; aparece en:&#10;- Categoría &quot;Deportes&quot; (categoryId: &quot;10&quot;)&#10;- Categoría &quot;HD Channels&quot; (categoryId: &quot;20&quot;)&#10;```&#10;&#10;Con el schema anterior, solo se podía guardar una de estas entradas, perdiendo información importante sobre la relación contenido-categoría.&#10;&#10;## Solución Implementada&#10;&#10;Se ha cambiado el diseño de las tablas para usar **claves primarias compuestas** que combinan el ID del contenido con el ID de la categoría.&#10;&#10;### Cambios en las Entidades&#10;&#10;#### 1. LiveStreamEntity&#10;**Antes:**&#10;```kotlin&#10;@Entity(tableName = &quot;live_streams&quot;)&#10;data class LiveStreamEntity(&#10;    @PrimaryKey val streamId: String,&#10;    val categoryId: String,&#10;    // ... otros campos&#10;)&#10;```&#10;&#10;**Después:**&#10;```kotlin&#10;@Entity(&#10;    tableName = &quot;live_streams&quot;,&#10;    primaryKeys = [&quot;streamId&quot;, &quot;categoryId&quot;]&#10;)&#10;data class LiveStreamEntity(&#10;    val streamId: String,&#10;    val categoryId: String,&#10;    // ... otros campos&#10;)&#10;```&#10;&#10;#### 2. VodStreamEntity&#10;**Antes:**&#10;```kotlin&#10;@Entity(tableName = &quot;vod_streams&quot;)&#10;data class VodStreamEntity(&#10;    @PrimaryKey val streamId: String,&#10;    val categoryId: String,&#10;    // ... otros campos&#10;)&#10;```&#10;&#10;**Después:**&#10;```kotlin&#10;@Entity(&#10;    tableName = &quot;vod_streams&quot;,&#10;    primaryKeys = [&quot;streamId&quot;, &quot;categoryId&quot;]&#10;)&#10;data class VodStreamEntity(&#10;    val streamId: String,&#10;    val categoryId: String,&#10;    // ... otros campos&#10;)&#10;```&#10;&#10;#### 3. SeriesEntity&#10;**Antes:**&#10;```kotlin&#10;@Entity(tableName = &quot;series&quot;)&#10;data class SeriesEntity(&#10;    @PrimaryKey val seriesId: String,&#10;    val categoryId: String,&#10;    // ... otros campos&#10;)&#10;```&#10;&#10;**Después:**&#10;```kotlin&#10;@Entity(&#10;    tableName = &quot;series&quot;,&#10;    primaryKeys = [&quot;seriesId&quot;, &quot;categoryId&quot;]&#10;)&#10;data class SeriesEntity(&#10;    val seriesId: String,&#10;    val categoryId: String,&#10;    // ... otros campos&#10;)&#10;```&#10;&#10;## Mejoras en los DAOs&#10;&#10;Se han agregado nuevos métodos de consulta para mayor flexibilidad:&#10;&#10;### LiveStreamDao&#10;```kotlin&#10;// Obtener todos los streams con un streamId específico (todas las categorías)&#10;suspend fun getLiveStreamsByStreamId(streamId: String): List&lt;LiveStreamEntity&gt;&#10;&#10;// Obtener un stream específico de una categoría específica&#10;suspend fun getLiveStream(streamId: String, categoryId: String): LiveStreamEntity?&#10;```&#10;&#10;### VodStreamDao&#10;```kotlin&#10;// Obtener todos los VOD con un streamId específico (todas las categorías)&#10;suspend fun getVodStreamsByStreamId(streamId: String): List&lt;VodStreamEntity&gt;&#10;&#10;// Obtener un VOD específico de una categoría específica&#10;suspend fun getVodStream(streamId: String, categoryId: String): VodStreamEntity?&#10;```&#10;&#10;### SeriesDao&#10;```kotlin&#10;// Obtener todas las series con un seriesId específico (todas las categorías)&#10;suspend fun getSeriesBySeriesId(seriesId: String): List&lt;SeriesEntity&gt;&#10;&#10;// Obtener una serie específica de una categoría específica&#10;suspend fun getSeries(seriesId: String, categoryId: String): SeriesEntity?&#10;```&#10;&#10;## Versión de Base de Datos&#10;&#10;La versión de la base de datos se ha incrementado de `1` a `2`:&#10;```kotlin&#10;@Database(&#10;    entities = [...],&#10;    version = 2,  // Incrementado desde 1&#10;    exportSchema = false&#10;)&#10;```&#10;&#10;## Impacto en la Aplicación&#10;&#10;### ✅ Ventajas:&#10;1. **Datos Completos**: Ahora se pueden guardar todos los streams/series aunque aparezcan en múltiples categorías&#10;2. **Relaciones Correctas**: Se mantiene la relación exacta entre contenido y categorías&#10;3. **Sin Conflictos**: No hay errores al insertar el mismo contenido en diferentes categorías&#10;4. **Consultas Flexibles**: Se pueden consultar streams por ID específico o por combinación ID+categoría&#10;&#10;### ⚠️ Consideraciones:&#10;1. **Duplicación de Datos**: El mismo stream puede estar guardado múltiples veces (una por categoría)&#10;   - Esto es intencional y refleja la estructura real de la API&#10;   - Permite filtrado correcto por categorías&#10;   &#10;2. **Migración Automática**: La base de datos se recreará automáticamente en la próxima ejecución&#10;   - Configurado con `.fallbackToDestructiveMigration()`&#10;   - Los datos antiguos se perderán (se recargarán desde la API)&#10;&#10;## Uso Recomendado&#10;&#10;### Para Mostrar Contenido por Categoría:&#10;```kotlin&#10;val streams = liveStreamDao.getLiveStreamsByCategory(&quot;10&quot;)&#10;```&#10;&#10;### Para Buscar Contenido Específico:&#10;```kotlin&#10;val stream = liveStreamDao.getLiveStream(&quot;12345&quot;, &quot;10&quot;)&#10;```&#10;&#10;### Para Ver Todas las Categorías de un Stream:&#10;```kotlin&#10;val allInstances = liveStreamDao.getLiveStreamsByStreamId(&quot;12345&quot;)&#10;// Retorna el mismo stream en todas sus categorías&#10;```&#10;&#10;## Archivos Modificados&#10;&#10;1. `data/db/Entities.kt` - Cambio de claves primarias&#10;2. `data/db/Daos.kt` - Nuevos métodos de consulta&#10;3. `data/db/PlayxyDatabase.kt` - Incremento de versión&#10;4. `util/EntityMapper.kt` - Sin cambios (ya estaba correcto)&#10;5. `data/repository/IptvRepository.kt` - Sin cambios (ya estaba correcto)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/data/db/Daos.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/data/db/Daos.kt" />
              <option name="originalContent" value="package com.iptv.playxy.data.db&#10;&#10;import androidx.room.*&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface UserProfileDao {&#10;    @Query(&quot;SELECT * FROM user_profiles WHERE id = 1&quot;)&#10;    suspend fun getProfile(): UserProfileEntity?&#10;    &#10;    @Query(&quot;SELECT * FROM user_profiles WHERE id = 1&quot;)&#10;    fun getProfileFlow(): Flow&lt;UserProfileEntity?&gt;&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertProfile(profile: UserProfileEntity)&#10;    &#10;    @Query(&quot;DELETE FROM user_profiles&quot;)&#10;    suspend fun deleteAllProfiles()&#10;}&#10;&#10;@Dao&#10;interface LiveStreamDao {&#10;    @Query(&quot;SELECT * FROM live_streams&quot;)&#10;    suspend fun getAllLiveStreams(): List&lt;LiveStreamEntity&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM live_streams WHERE categoryId = :categoryId&quot;)&#10;    suspend fun getLiveStreamsByCategory(categoryId: String): List&lt;LiveStreamEntity&gt;&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertAll(streams: List&lt;LiveStreamEntity&gt;)&#10;    &#10;    @Query(&quot;DELETE FROM live_streams&quot;)&#10;    suspend fun deleteAll()&#10;}&#10;&#10;@Dao&#10;interface VodStreamDao {&#10;    @Query(&quot;SELECT * FROM vod_streams&quot;)&#10;    suspend fun getAllVodStreams(): List&lt;VodStreamEntity&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM vod_streams WHERE categoryId = :categoryId&quot;)&#10;    suspend fun getVodStreamsByCategory(categoryId: String): List&lt;VodStreamEntity&gt;&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertAll(streams: List&lt;VodStreamEntity&gt;)&#10;    &#10;    @Query(&quot;DELETE FROM vod_streams&quot;)&#10;    suspend fun deleteAll()&#10;}&#10;&#10;@Dao&#10;interface SeriesDao {&#10;    @Query(&quot;SELECT * FROM series&quot;)&#10;    suspend fun getAllSeries(): List&lt;SeriesEntity&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM series WHERE categoryId = :categoryId&quot;)&#10;    suspend fun getSeriesByCategory(categoryId: String): List&lt;SeriesEntity&gt;&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertAll(series: List&lt;SeriesEntity&gt;)&#10;    &#10;    @Query(&quot;DELETE FROM series&quot;)&#10;    suspend fun deleteAll()&#10;}&#10;&#10;@Dao&#10;interface CategoryDao {&#10;    @Query(&quot;SELECT * FROM categories&quot;)&#10;    suspend fun getAllCategories(): List&lt;CategoryEntity&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM categories WHERE type = :type&quot;)&#10;    suspend fun getCategoriesByType(type: String): List&lt;CategoryEntity&gt;&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertAll(categories: List&lt;CategoryEntity&gt;)&#10;    &#10;    @Query(&quot;DELETE FROM categories&quot;)&#10;    suspend fun deleteAll()&#10;}&#10;&#10;@Dao&#10;interface CacheMetadataDao {&#10;    @Query(&quot;SELECT * FROM cache_metadata WHERE key = :key&quot;)&#10;    suspend fun getCacheMetadata(key: String): CacheMetadata?&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertCacheMetadata(metadata: CacheMetadata)&#10;    &#10;    @Query(&quot;DELETE FROM cache_metadata&quot;)&#10;    suspend fun deleteAll()&#10;}&#10;" />
              <option name="updatedContent" value="package com.iptv.playxy.data.db&#10;&#10;import androidx.room.*&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface UserProfileDao {&#10;    @Query(&quot;SELECT * FROM user_profiles WHERE id = 1&quot;)&#10;    suspend fun getProfile(): UserProfileEntity?&#10;    &#10;    @Query(&quot;SELECT * FROM user_profiles WHERE id = 1&quot;)&#10;    fun getProfileFlow(): Flow&lt;UserProfileEntity?&gt;&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertProfile(profile: UserProfileEntity)&#10;    &#10;    @Query(&quot;DELETE FROM user_profiles&quot;)&#10;    suspend fun deleteAllProfiles()&#10;}&#10;&#10;@Dao&#10;interface LiveStreamDao {&#10;    @Query(&quot;SELECT * FROM live_streams&quot;)&#10;    suspend fun getAllLiveStreams(): List&lt;LiveStreamEntity&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM live_streams WHERE categoryId = :categoryId&quot;)&#10;    suspend fun getLiveStreamsByCategory(categoryId: String): List&lt;LiveStreamEntity&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM live_streams WHERE streamId = :streamId&quot;)&#10;    suspend fun getLiveStreamsByStreamId(streamId: String): List&lt;LiveStreamEntity&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM live_streams WHERE streamId = :streamId AND categoryId = :categoryId&quot;)&#10;    suspend fun getLiveStream(streamId: String, categoryId: String): LiveStreamEntity?&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertAll(streams: List&lt;LiveStreamEntity&gt;)&#10;    &#10;    @Query(&quot;DELETE FROM live_streams&quot;)&#10;    suspend fun deleteAll()&#10;}&#10;&#10;@Dao&#10;interface VodStreamDao {&#10;    @Query(&quot;SELECT * FROM vod_streams&quot;)&#10;    suspend fun getAllVodStreams(): List&lt;VodStreamEntity&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM vod_streams WHERE categoryId = :categoryId&quot;)&#10;    suspend fun getVodStreamsByCategory(categoryId: String): List&lt;VodStreamEntity&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM vod_streams WHERE streamId = :streamId&quot;)&#10;    suspend fun getVodStreamsByStreamId(streamId: String): List&lt;VodStreamEntity&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM vod_streams WHERE streamId = :streamId AND categoryId = :categoryId&quot;)&#10;    suspend fun getVodStream(streamId: String, categoryId: String): VodStreamEntity?&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertAll(streams: List&lt;VodStreamEntity&gt;)&#10;    &#10;    @Query(&quot;DELETE FROM vod_streams&quot;)&#10;    suspend fun deleteAll()&#10;}&#10;&#10;@Dao&#10;interface SeriesDao {&#10;    @Query(&quot;SELECT * FROM series&quot;)&#10;    suspend fun getAllSeries(): List&lt;SeriesEntity&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM series WHERE categoryId = :categoryId&quot;)&#10;    suspend fun getSeriesByCategory(categoryId: String): List&lt;SeriesEntity&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM series WHERE seriesId = :seriesId&quot;)&#10;    suspend fun getSeriesBySeriesId(seriesId: String): List&lt;SeriesEntity&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM series WHERE seriesId = :seriesId AND categoryId = :categoryId&quot;)&#10;    suspend fun getSeries(seriesId: String, categoryId: String): SeriesEntity?&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertAll(series: List&lt;SeriesEntity&gt;)&#10;    &#10;    @Query(&quot;DELETE FROM series&quot;)&#10;    suspend fun deleteAll()&#10;}&#10;&#10;@Dao&#10;interface CategoryDao {&#10;    @Query(&quot;SELECT * FROM categories&quot;)&#10;    suspend fun getAllCategories(): List&lt;CategoryEntity&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM categories WHERE type = :type&quot;)&#10;    suspend fun getCategoriesByType(type: String): List&lt;CategoryEntity&gt;&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertAll(categories: List&lt;CategoryEntity&gt;)&#10;    &#10;    @Query(&quot;DELETE FROM categories&quot;)&#10;    suspend fun deleteAll()&#10;}&#10;&#10;@Dao&#10;interface CacheMetadataDao {&#10;    @Query(&quot;SELECT * FROM cache_metadata WHERE key = :key&quot;)&#10;    suspend fun getCacheMetadata(key: String): CacheMetadata?&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertCacheMetadata(metadata: CacheMetadata)&#10;    &#10;    @Query(&quot;DELETE FROM cache_metadata&quot;)&#10;    suspend fun deleteAll()&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/data/db/Entities.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/data/db/Entities.kt" />
              <option name="originalContent" value="package com.iptv.playxy.data.db&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;import androidx.room.TypeConverters&#10;&#10;@Entity(tableName = &quot;user_profiles&quot;)&#10;data class UserProfileEntity(&#10;    @PrimaryKey val id: Int = 1,&#10;    val profileName: String,&#10;    val username: String,&#10;    val password: String,&#10;    val url: String,&#10;    val lastUpdated: Long,&#10;    val isValid: Boolean&#10;)&#10;&#10;@Entity(tableName = &quot;live_streams&quot;)&#10;data class LiveStreamEntity(&#10;    @PrimaryKey val streamId: String,&#10;    val name: String,&#10;    val streamIcon: String?,&#10;    val isAdult: Boolean,&#10;    val categoryId: String,&#10;    val tvArchive: Boolean,&#10;    val epgChannelId: String?,&#10;    val added: String?,&#10;    val customSid: String?,&#10;    val directSource: String?,&#10;    val tvArchiveDuration: Int&#10;)&#10;&#10;@Entity(tableName = &quot;vod_streams&quot;)&#10;data class VodStreamEntity(&#10;    @PrimaryKey val streamId: String,&#10;    val name: String,&#10;    val streamIcon: String?,&#10;    val tmdbId: String?,&#10;    val rating: Float,&#10;    val rating5Based: Float,&#10;    val containerExtension: String,&#10;    val added: String?,&#10;    val isAdult: Boolean,&#10;    val categoryId: String,&#10;    val customSid: String?,&#10;    val directSource: String?&#10;)&#10;&#10;@Entity(tableName = &quot;series&quot;)&#10;data class SeriesEntity(&#10;    @PrimaryKey val seriesId: String,&#10;    val name: String,&#10;    val cover: String?,&#10;    val plot: String?,&#10;    val cast: String?,&#10;    val director: String?,&#10;    val genre: String?,&#10;    val releaseDate: String?,&#10;    val rating: Float,&#10;    val rating5Based: Float,&#10;    @TypeConverters(Converters::class)&#10;    val backdropPath: String,&#10;    val youtubeTrailer: String?,&#10;    val episodeRunTime: String?,&#10;    val categoryId: String,&#10;    val tmdbId: String?,&#10;    val lastModified: String?&#10;)&#10;&#10;@Entity(tableName = &quot;categories&quot;)&#10;data class CategoryEntity(&#10;    @PrimaryKey val categoryId: String,&#10;    val categoryName: String,&#10;    val parentId: String,&#10;    val type: String // &quot;live&quot;, &quot;vod&quot;, or &quot;series&quot;&#10;)&#10;&#10;@Entity(tableName = &quot;cache_metadata&quot;)&#10;data class CacheMetadata(&#10;    @PrimaryKey val key: String,&#10;    val lastUpdated: Long&#10;)&#10;" />
              <option name="updatedContent" value="package com.iptv.playxy.data.db&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;import androidx.room.TypeConverters&#10;&#10;@Entity(tableName = &quot;user_profiles&quot;)&#10;data class UserProfileEntity(&#10;    @PrimaryKey val id: Int = 1,&#10;    val profileName: String,&#10;    val username: String,&#10;    val password: String,&#10;    val url: String,&#10;    val lastUpdated: Long,&#10;    val isValid: Boolean&#10;)&#10;&#10;@Entity(&#10;    tableName = &quot;live_streams&quot;,&#10;    primaryKeys = [&quot;streamId&quot;, &quot;categoryId&quot;]&#10;)&#10;data class LiveStreamEntity(&#10;    val streamId: String,&#10;    val categoryId: String,&#10;    val name: String,&#10;    val streamIcon: String?,&#10;    val isAdult: Boolean,&#10;    val tvArchive: Boolean,&#10;    val epgChannelId: String?,&#10;    val added: String?,&#10;    val customSid: String?,&#10;    val directSource: String?,&#10;    val tvArchiveDuration: Int&#10;)&#10;&#10;@Entity(&#10;    tableName = &quot;vod_streams&quot;,&#10;    primaryKeys = [&quot;streamId&quot;, &quot;categoryId&quot;]&#10;)&#10;data class VodStreamEntity(&#10;    val streamId: String,&#10;    val categoryId: String,&#10;    val name: String,&#10;    val streamIcon: String?,&#10;    val tmdbId: String?,&#10;    val rating: Float,&#10;    val rating5Based: Float,&#10;    val containerExtension: String,&#10;    val added: String?,&#10;    val isAdult: Boolean,&#10;    val customSid: String?,&#10;    val directSource: String?&#10;)&#10;&#10;@Entity(&#10;    tableName = &quot;series&quot;,&#10;    primaryKeys = [&quot;seriesId&quot;, &quot;categoryId&quot;]&#10;)&#10;data class SeriesEntity(&#10;    val seriesId: String,&#10;    val categoryId: String,&#10;    val name: String,&#10;    val cover: String?,&#10;    val plot: String?,&#10;    val cast: String?,&#10;    val director: String?,&#10;    val genre: String?,&#10;    val releaseDate: String?,&#10;    val rating: Float,&#10;    val rating5Based: Float,&#10;    @TypeConverters(Converters::class)&#10;    val backdropPath: String,&#10;    val youtubeTrailer: String?,&#10;    val episodeRunTime: String?,&#10;    val tmdbId: String?,&#10;    val lastModified: String?&#10;)&#10;&#10;@Entity(tableName = &quot;categories&quot;)&#10;data class CategoryEntity(&#10;    @PrimaryKey val categoryId: String,&#10;    val categoryName: String,&#10;    val parentId: String,&#10;    val type: String // &quot;live&quot;, &quot;vod&quot;, or &quot;series&quot;&#10;)&#10;&#10;@Entity(tableName = &quot;cache_metadata&quot;)&#10;data class CacheMetadata(&#10;    @PrimaryKey val key: String,&#10;    val lastUpdated: Long&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/data/db/PlayxyDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/data/db/PlayxyDatabase.kt" />
              <option name="originalContent" value="package com.iptv.playxy.data.db&#10;&#10;import androidx.room.Database&#10;import androidx.room.RoomDatabase&#10;import androidx.room.TypeConverters&#10;&#10;@Database(&#10;    entities = [&#10;        UserProfileEntity::class,&#10;        LiveStreamEntity::class,&#10;        VodStreamEntity::class,&#10;        SeriesEntity::class,&#10;        CategoryEntity::class,&#10;        CacheMetadata::class&#10;    ],&#10;    version = 1,&#10;    exportSchema = false&#10;)&#10;@TypeConverters(Converters::class)&#10;abstract class PlayxyDatabase : RoomDatabase() {&#10;    abstract fun userProfileDao(): UserProfileDao&#10;    abstract fun liveStreamDao(): LiveStreamDao&#10;    abstract fun vodStreamDao(): VodStreamDao&#10;    abstract fun seriesDao(): SeriesDao&#10;    abstract fun categoryDao(): CategoryDao&#10;    abstract fun cacheMetadataDao(): CacheMetadataDao&#10;}&#10;" />
              <option name="updatedContent" value="package com.iptv.playxy.data.db&#10;&#10;import androidx.room.Database&#10;import androidx.room.RoomDatabase&#10;import androidx.room.TypeConverters&#10;&#10;@Database(&#10;    entities = [&#10;        UserProfileEntity::class,&#10;        LiveStreamEntity::class,&#10;        VodStreamEntity::class,&#10;        SeriesEntity::class,&#10;        CategoryEntity::class,&#10;        CacheMetadata::class&#10;    ],&#10;    version = 2,&#10;    exportSchema = false&#10;)&#10;@TypeConverters(Converters::class)&#10;abstract class PlayxyDatabase : RoomDatabase() {&#10;    abstract fun userProfileDao(): UserProfileDao&#10;    abstract fun liveStreamDao(): LiveStreamDao&#10;    abstract fun vodStreamDao(): VodStreamDao&#10;    abstract fun seriesDao(): SeriesDao&#10;    abstract fun categoryDao(): CategoryDao&#10;    abstract fun cacheMetadataDao(): CacheMetadataDao&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/data/repository/IptvRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/data/repository/IptvRepository.kt" />
              <option name="originalContent" value="package com.iptv.playxy.data.repository&#10;&#10;import com.iptv.playxy.data.api.IptvApiService&#10;import com.iptv.playxy.data.db.*&#10;import com.iptv.playxy.domain.*&#10;import com.iptv.playxy.util.EntityMapper&#10;import com.iptv.playxy.util.ResponseMapper&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Repository for managing IPTV content data&#10; * Coordinates between local database and remote API&#10; */&#10;@Singleton&#10;class IptvRepository @Inject constructor(&#10;    private val apiService: IptvApiService,&#10;    private val database: PlayxyDatabase&#10;) {&#10;    private val userProfileDao = database.userProfileDao()&#10;    private val liveStreamDao = database.liveStreamDao()&#10;    private val vodStreamDao = database.vodStreamDao()&#10;    private val seriesDao = database.seriesDao()&#10;    private val categoryDao = database.categoryDao()&#10;    private val cacheMetadataDao = database.cacheMetadataDao()&#10;    &#10;    // Cache expiration time (24 hours)&#10;    private val cacheExpirationTime = 24 * 60 * 60 * 1000L&#10;    &#10;    // User Profile operations&#10;    suspend fun getProfile(): UserProfile? {&#10;        return userProfileDao.getProfile()?.let { EntityMapper.toDomain(it) }&#10;    }&#10;    &#10;    fun getProfileFlow(): Flow&lt;UserProfile?&gt; {&#10;        return userProfileDao.getProfileFlow().map { it?.let { EntityMapper.toDomain(it) } }&#10;    }&#10;    &#10;    suspend fun saveProfile(profile: UserProfile) {&#10;        userProfileDao.insertProfile(EntityMapper.toEntity(profile))&#10;    }&#10;    &#10;    suspend fun deleteProfile() {&#10;        userProfileDao.deleteAllProfiles()&#10;    }&#10;    &#10;    suspend fun validateCredentials(username: String, password: String, baseUrl: String): Boolean {&#10;        return try {&#10;            // Create a temporary api service with the base URL&#10;            val response = apiService.validateCredentials(username, password)&#10;            response.isSuccessful&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;    &#10;    // Content loading operations&#10;    suspend fun loadAllContent(username: String, password: String): Result&lt;Unit&gt; {&#10;        return try {&#10;            // Load all content types in parallel (simplified sequential for now)&#10;            loadLiveStreams(username, password)&#10;            loadVodStreams(username, password)&#10;            loadSeries(username, password)&#10;            loadCategories(username, password)&#10;            &#10;            // Update cache metadata&#10;            val currentTime = System.currentTimeMillis()&#10;            cacheMetadataDao.insertCacheMetadata(CacheMetadata(&quot;all_content&quot;, currentTime))&#10;            &#10;            Result.success(Unit)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;    &#10;    private suspend fun loadLiveStreams(username: String, password: String) {&#10;        val response = apiService.getLiveStreams(username, password)&#10;        if (response.isSuccessful) {&#10;            val streams = response.body()?.map { ResponseMapper.toLiveStream(it) } ?: emptyList()&#10;            liveStreamDao.deleteAll()&#10;            liveStreamDao.insertAll(streams.map { EntityMapper.toEntity(it) })&#10;        }&#10;    }&#10;    &#10;    private suspend fun loadVodStreams(username: String, password: String) {&#10;        val response = apiService.getVodStreams(username, password)&#10;        if (response.isSuccessful) {&#10;            val streams = response.body()?.map { ResponseMapper.toVodStream(it) } ?: emptyList()&#10;            vodStreamDao.deleteAll()&#10;            vodStreamDao.insertAll(streams.map { EntityMapper.toEntity(it) })&#10;        }&#10;    }&#10;    &#10;    private suspend fun loadSeries(username: String, password: String) {&#10;        val response = apiService.getSeries(username, password)&#10;        if (response.isSuccessful) {&#10;            val series = response.body()?.map { ResponseMapper.toSeries(it) } ?: emptyList()&#10;            seriesDao.deleteAll()&#10;            seriesDao.insertAll(series.map { EntityMapper.toEntity(it) })&#10;        }&#10;    }&#10;    &#10;    private suspend fun loadCategories(username: String, password: String) {&#10;        categoryDao.deleteAll()&#10;        &#10;        // Load live categories&#10;        val liveResponse = apiService.getLiveCategories(username, password)&#10;        if (liveResponse.isSuccessful) {&#10;            val categories = liveResponse.body()?.map { ResponseMapper.toCategory(it) } ?: emptyList()&#10;            categoryDao.insertAll(categories.map { EntityMapper.toEntity(it, &quot;live&quot;) })&#10;        }&#10;        &#10;        // Load VOD categories&#10;        val vodResponse = apiService.getVodCategories(username, password)&#10;        if (vodResponse.isSuccessful) {&#10;            val categories = vodResponse.body()?.map { ResponseMapper.toCategory(it) } ?: emptyList()&#10;            categoryDao.insertAll(categories.map { EntityMapper.toEntity(it, &quot;vod&quot;) })&#10;        }&#10;        &#10;        // Load series categories&#10;        val seriesResponse = apiService.getSeriesCategories(username, password)&#10;        if (seriesResponse.isSuccessful) {&#10;            val categories = seriesResponse.body()?.map { ResponseMapper.toCategory(it) } ?: emptyList()&#10;            categoryDao.insertAll(categories.map { EntityMapper.toEntity(it, &quot;series&quot;) })&#10;        }&#10;    }&#10;    &#10;    // Cache management&#10;    suspend fun isCacheValid(): Boolean {&#10;        val metadata = cacheMetadataDao.getCacheMetadata(&quot;all_content&quot;)&#10;        return if (metadata != null) {&#10;            val currentTime = System.currentTimeMillis()&#10;            (currentTime - metadata.lastUpdated) &lt; cacheExpirationTime&#10;        } else {&#10;            false&#10;        }&#10;    }&#10;    &#10;    suspend fun hasCachedContent(): Boolean {&#10;        val liveStreams = liveStreamDao.getAllLiveStreams()&#10;        val vodStreams = vodStreamDao.getAllVodStreams()&#10;        val series = seriesDao.getAllSeries()&#10;        return liveStreams.isNotEmpty() || vodStreams.isNotEmpty() || series.isNotEmpty()&#10;    }&#10;    &#10;    suspend fun clearCache() {&#10;        liveStreamDao.deleteAll()&#10;        vodStreamDao.deleteAll()&#10;        seriesDao.deleteAll()&#10;        categoryDao.deleteAll()&#10;        cacheMetadataDao.deleteAll()&#10;    }&#10;    &#10;    // Content retrieval from cache&#10;    suspend fun getLiveStreams(): List&lt;LiveStream&gt; {&#10;        return liveStreamDao.getAllLiveStreams().map { EntityMapper.liveStreamToDomain(it) }&#10;    }&#10;    &#10;    suspend fun getVodStreams(): List&lt;VodStream&gt; {&#10;        return vodStreamDao.getAllVodStreams().map { EntityMapper.vodStreamToDomain(it) }&#10;    }&#10;    &#10;    suspend fun getSeries(): List&lt;Series&gt; {&#10;        return seriesDao.getAllSeries().map { EntityMapper.seriesToDomain(it) }&#10;    }&#10;    &#10;    suspend fun getCategories(type: String): List&lt;Category&gt; {&#10;        return categoryDao.getCategoriesByType(type).map { EntityMapper.categoryToDomain(it) }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.iptv.playxy.data.repository&#13;&#10;&#13;&#10;import com.iptv.playxy.data.api.IptvApiService&#13;&#10;import com.iptv.playxy.data.db.*&#13;&#10;import com.iptv.playxy.domain.*&#13;&#10;import com.iptv.playxy.util.EntityMapper&#13;&#10;import com.iptv.playxy.util.ResponseMapper&#13;&#10;import kotlinx.coroutines.flow.Flow&#13;&#10;import kotlinx.coroutines.flow.map&#13;&#10;import javax.inject.Inject&#13;&#10;import javax.inject.Singleton&#13;&#10;&#13;&#10;/**&#13;&#10; * Repository for managing IPTV content data&#13;&#10; * Coordinates between local database and remote API&#13;&#10; */&#13;&#10;@Singleton&#13;&#10;class IptvRepository @Inject constructor(&#13;&#10;    private val apiService: IptvApiService,&#13;&#10;    private val database: PlayxyDatabase&#13;&#10;) {&#13;&#10;    private val userProfileDao = database.userProfileDao()&#13;&#10;    private val liveStreamDao = database.liveStreamDao()&#13;&#10;    private val vodStreamDao = database.vodStreamDao()&#13;&#10;    private val seriesDao = database.seriesDao()&#13;&#10;    private val categoryDao = database.categoryDao()&#13;&#10;    private val cacheMetadataDao = database.cacheMetadataDao()&#13;&#10;    &#13;&#10;    // Cache expiration time (24 hours)&#13;&#10;    private val cacheExpirationTime = 24 * 60 * 60 * 1000L&#13;&#10;    &#13;&#10;    // User Profile operations&#13;&#10;    suspend fun getProfile(): UserProfile? {&#13;&#10;        return userProfileDao.getProfile()?.let { EntityMapper.toDomain(it) }&#13;&#10;    }&#13;&#10;    &#13;&#10;    fun getProfileFlow(): Flow&lt;UserProfile?&gt; {&#13;&#10;        return userProfileDao.getProfileFlow().map { it?.let { EntityMapper.toDomain(it) } }&#13;&#10;    }&#13;&#10;    &#13;&#10;    suspend fun saveProfile(profile: UserProfile) {&#13;&#10;        userProfileDao.insertProfile(EntityMapper.toEntity(profile))&#13;&#10;    }&#13;&#10;    &#13;&#10;    suspend fun deleteProfile() {&#13;&#10;        userProfileDao.deleteAllProfiles()&#13;&#10;    }&#13;&#10;    &#13;&#10;    suspend fun validateCredentials(username: String, password: String, baseUrl: String): Boolean {&#13;&#10;        return try {&#13;&#10;            // Create a temporary api service with the base URL&#13;&#10;            val response = apiService.validateCredentials(username, password)&#13;&#10;            response.isSuccessful&#13;&#10;        } catch (e: Exception) {&#13;&#10;            false&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    // Content loading operations&#13;&#10;    suspend fun loadAllContent(username: String, password: String): Result&lt;Unit&gt; {&#13;&#10;        return try {&#13;&#10;            // Load all content types in parallel (simplified sequential for now)&#13;&#10;            loadLiveStreams(username, password)&#13;&#10;            loadVodStreams(username, password)&#13;&#10;            loadSeries(username, password)&#13;&#10;            loadCategories(username, password)&#13;&#10;            &#13;&#10;            // Update cache metadata&#13;&#10;            val currentTime = System.currentTimeMillis()&#13;&#10;            cacheMetadataDao.insertCacheMetadata(CacheMetadata(&quot;all_content&quot;, currentTime))&#13;&#10;            &#13;&#10;            Result.success(Unit)&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Result.failure(e)&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    private suspend fun loadLiveStreams(username: String, password: String) {&#13;&#10;        val response = apiService.getLiveStreams(username, password)&#13;&#10;        if (response.isSuccessful) {&#13;&#10;            val streams = response.body()?.map { ResponseMapper.toLiveStream(it) } ?: emptyList()&#13;&#10;            liveStreamDao.deleteAll()&#13;&#10;            liveStreamDao.insertAll(streams.map { EntityMapper.toEntity(it) })&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    private suspend fun loadVodStreams(username: String, password: String) {&#13;&#10;        val response = apiService.getVodStreams(username, password)&#13;&#10;        if (response.isSuccessful) {&#13;&#10;            val streams = response.body()?.map { ResponseMapper.toVodStream(it) } ?: emptyList()&#13;&#10;            vodStreamDao.deleteAll()&#13;&#10;            vodStreamDao.insertAll(streams.map { EntityMapper.toEntity(it) })&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    private suspend fun loadSeries(username: String, password: String) {&#13;&#10;        val response = apiService.getSeries(username, password)&#13;&#10;        if (response.isSuccessful) {&#13;&#10;            val series = response.body()?.map { ResponseMapper.toSeries(it) } ?: emptyList()&#13;&#10;            seriesDao.deleteAll()&#13;&#10;            seriesDao.insertAll(series.map { EntityMapper.toEntity(it) })&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    private suspend fun loadCategories(username: String, password: String) {&#13;&#10;        categoryDao.deleteAll()&#13;&#10;        &#13;&#10;        // Load live categories&#13;&#10;        val liveResponse = apiService.getLiveCategories(username, password)&#13;&#10;        if (liveResponse.isSuccessful) {&#13;&#10;            val categories = liveResponse.body()?.map { ResponseMapper.toCategory(it) } ?: emptyList()&#13;&#10;            categoryDao.insertAll(categories.map { EntityMapper.toEntity(it, &quot;live&quot;) })&#13;&#10;        }&#13;&#10;        &#13;&#10;        // Load VOD categories&#13;&#10;        val vodResponse = apiService.getVodCategories(username, password)&#13;&#10;        if (vodResponse.isSuccessful) {&#13;&#10;            val categories = vodResponse.body()?.map { ResponseMapper.toCategory(it) } ?: emptyList()&#13;&#10;            categoryDao.insertAll(categories.map { EntityMapper.toEntity(it, &quot;vod&quot;) })&#13;&#10;        }&#13;&#10;        &#13;&#10;        // Load series categories&#13;&#10;        val seriesResponse = apiService.getSeriesCategories(username, password)&#13;&#10;        if (seriesResponse.isSuccessful) {&#13;&#10;            val categories = seriesResponse.body()?.map { ResponseMapper.toCategory(it) } ?: emptyList()&#13;&#10;            categoryDao.insertAll(categories.map { EntityMapper.toEntity(it, &quot;series&quot;) })&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    // Cache management&#13;&#10;    suspend fun isCacheValid(): Boolean {&#13;&#10;        val metadata = cacheMetadataDao.getCacheMetadata(&quot;all_content&quot;)&#13;&#10;        return if (metadata != null) {&#13;&#10;            val currentTime = System.currentTimeMillis()&#13;&#10;            (currentTime - metadata.lastUpdated) &lt; cacheExpirationTime&#13;&#10;        } else {&#13;&#10;            false&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    suspend fun hasCachedContent(): Boolean {&#13;&#10;        val liveStreams = liveStreamDao.getAllLiveStreams()&#13;&#10;        val vodStreams = vodStreamDao.getAllVodStreams()&#13;&#10;        val series = seriesDao.getAllSeries()&#13;&#10;        return liveStreams.isNotEmpty() || vodStreams.isNotEmpty() || series.isNotEmpty()&#13;&#10;    }&#13;&#10;    &#13;&#10;    suspend fun clearCache() {&#13;&#10;        liveStreamDao.deleteAll()&#13;&#10;        vodStreamDao.deleteAll()&#13;&#10;        seriesDao.deleteAll()&#13;&#10;        categoryDao.deleteAll()&#13;&#10;        cacheMetadataDao.deleteAll()&#13;&#10;    }&#13;&#10;    &#13;&#10;    // Content retrieval from cache&#10;    suspend fun getLiveStreams(): List&lt;LiveStream&gt; {&#10;        return liveStreamDao.getAllLiveStreams().map { EntityMapper.liveStreamToDomain(it) }&#10;    }&#10;    &#10;    suspend fun getLiveStreamsByCategory(categoryId: String): List&lt;LiveStream&gt; {&#10;        return liveStreamDao.getLiveStreamsByCategory(categoryId).map { EntityMapper.liveStreamToDomain(it) }&#10;    }&#10;    &#10;    suspend fun getVodStreams(): List&lt;VodStream&gt; {&#10;        return vodStreamDao.getAllVodStreams().map { EntityMapper.vodStreamToDomain(it) }&#10;    }&#10;    &#10;    suspend fun getVodStreamsByCategory(categoryId: String): List&lt;VodStream&gt; {&#10;        return vodStreamDao.getVodStreamsByCategory(categoryId).map { EntityMapper.vodStreamToDomain(it) }&#10;    }&#10;    &#10;    suspend fun getSeries(): List&lt;Series&gt; {&#10;        return seriesDao.getAllSeries().map { EntityMapper.seriesToDomain(it) }&#10;    }&#10;    &#10;    suspend fun getSeriesByCategory(categoryId: String): List&lt;Series&gt; {&#10;        return seriesDao.getSeriesByCategory(categoryId).map { EntityMapper.seriesToDomain(it) }&#10;    }&#10;    &#10;    suspend fun getCategories(type: String): List&lt;Category&gt; {&#10;        return categoryDao.getCategoriesByType(type).map { EntityMapper.categoryToDomain(it) }&#10;    }&#10;    &#10;    suspend fun getAllCategories(): List&lt;Category&gt; {&#10;        return categoryDao.getAllCategories().map { EntityMapper.categoryToDomain(it) }&#10;    }&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>