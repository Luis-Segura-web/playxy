<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/data/db/Entities.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/data/db/Entities.kt" />
              <option name="originalContent" value="package com.iptv.playxy.data.db&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;import androidx.room.TypeConverters&#10;&#10;@Entity(tableName = &quot;user_profiles&quot;)&#10;data class UserProfileEntity(&#10;    @PrimaryKey val id: Int = 1,&#10;    val profileName: String,&#10;    val username: String,&#10;    val password: String,&#10;    val url: String,&#10;    val lastUpdated: Long,&#10;    val isValid: Boolean&#10;)&#10;&#10;@Entity(&#10;    tableName = &quot;live_streams&quot;,&#10;    primaryKeys = [&quot;streamId&quot;, &quot;categoryId&quot;]&#10;)&#10;data class LiveStreamEntity(&#10;    val streamId: String,&#10;    val categoryId: String,&#10;    val name: String,&#10;    val streamIcon: String?,&#10;    val isAdult: Boolean,&#10;    val tvArchive: Boolean,&#10;    val epgChannelId: String?,&#10;    val added: String?,&#10;    val customSid: String?,&#10;    val directSource: String?,&#10;    val tvArchiveDuration: Int&#10;)&#10;&#10;@Entity(&#10;    tableName = &quot;vod_streams&quot;,&#10;    primaryKeys = [&quot;streamId&quot;, &quot;categoryId&quot;]&#10;)&#10;data class VodStreamEntity(&#10;    val streamId: String,&#10;    val categoryId: String,&#10;    val name: String,&#10;    val streamIcon: String?,&#10;    val tmdbId: String?,&#10;    val rating: Float,&#10;    val rating5Based: Float,&#10;    val containerExtension: String,&#10;    val added: String?,&#10;    val isAdult: Boolean,&#10;    val customSid: String?,&#10;    val directSource: String?&#10;)&#10;&#10;@Entity(&#10;    tableName = &quot;series&quot;,&#10;    primaryKeys = [&quot;seriesId&quot;, &quot;categoryId&quot;]&#10;)&#10;data class SeriesEntity(&#10;    val seriesId: String,&#10;    val categoryId: String,&#10;    val name: String,&#10;    val cover: String?,&#10;    val plot: String?,&#10;    val cast: String?,&#10;    val director: String?,&#10;    val genre: String?,&#10;    val releaseDate: String?,&#10;    val rating: Float,&#10;    val rating5Based: Float,&#10;    @param:TypeConverters(Converters::class)&#10;    val backdropPath: String,&#10;    val youtubeTrailer: String?,&#10;    val episodeRunTime: String?,&#10;    val tmdbId: String?,&#10;    val lastModified: String?&#10;)&#10;&#10;@Entity(tableName = &quot;categories&quot;)&#10;data class CategoryEntity(&#10;    @PrimaryKey val categoryId: String,&#10;    val categoryName: String,&#10;    val parentId: String,&#10;    val type: String // &quot;live&quot;, &quot;vod&quot;, or &quot;series&quot;&#10;)&#10;&#10;@Entity(tableName = &quot;cache_metadata&quot;)&#10;data class CacheMetadata(&#10;    @PrimaryKey val key: String,&#10;    val lastUpdated: Long&#10;)&#10;&#10;@Entity(tableName = &quot;favorite_channels&quot;)&#10;data class FavoriteChannelEntity(&#10;    @PrimaryKey val channelId: String,&#10;    val timestamp: Long&#10;)&#10;&#10;@Entity(tableName = &quot;recent_channels&quot;)&#10;data class RecentChannelEntity(&#10;    @PrimaryKey(autoGenerate = true) val id: Int = 0,&#10;    val channelId: String,&#10;    val timestamp: Long&#10;)&#10;" />
              <option name="updatedContent" value="package com.iptv.playxy.data.db&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;import androidx.room.TypeConverters&#10;&#10;@Entity(tableName = &quot;user_profiles&quot;)&#10;data class UserProfileEntity(&#10;    @PrimaryKey val id: Int = 1,&#10;    val profileName: String,&#10;    val username: String,&#10;    val password: String,&#10;    val url: String,&#10;    val lastUpdated: Long,&#10;    val isValid: Boolean&#10;)&#10;&#10;@Entity(&#10;    tableName = &quot;live_streams&quot;,&#10;    primaryKeys = [&quot;streamId&quot;, &quot;categoryId&quot;]&#10;)&#10;data class LiveStreamEntity(&#10;    val streamId: String,&#10;    val categoryId: String,&#10;    val name: String,&#10;    val streamIcon: String?,&#10;    val isAdult: Boolean,&#10;    val tvArchive: Boolean,&#10;    val epgChannelId: String?,&#10;    val added: String?,&#10;    val customSid: String?,&#10;    val directSource: String?,&#10;    val tvArchiveDuration: Int&#10;)&#10;&#10;@Entity(&#10;    tableName = &quot;vod_streams&quot;,&#10;    primaryKeys = [&quot;streamId&quot;, &quot;categoryId&quot;]&#10;)&#10;data class VodStreamEntity(&#10;    val streamId: String,&#10;    val categoryId: String,&#10;    val name: String,&#10;    val streamIcon: String?,&#10;    val tmdbId: String?,&#10;    val rating: Float,&#10;    val rating5Based: Float,&#10;    val containerExtension: String,&#10;    val added: String?,&#10;    val isAdult: Boolean,&#10;    val customSid: String?,&#10;    val directSource: String?&#10;)&#10;&#10;@Entity(&#10;    tableName = &quot;series&quot;,&#10;    primaryKeys = [&quot;seriesId&quot;, &quot;categoryId&quot;]&#10;)&#10;data class SeriesEntity(&#10;    val seriesId: String,&#10;    val categoryId: String,&#10;    val name: String,&#10;    val cover: String?,&#10;    val plot: String?,&#10;    val cast: String?,&#10;    val director: String?,&#10;    val genre: String?,&#10;    val releaseDate: String?,&#10;    val rating: Float,&#10;    val rating5Based: Float,&#10;    @param:TypeConverters(Converters::class)&#10;    val backdropPath: String,&#10;    val youtubeTrailer: String?,&#10;    val episodeRunTime: String?,&#10;    val tmdbId: String?,&#10;    val lastModified: String?&#10;)&#10;&#10;@Entity(tableName = &quot;categories&quot;)&#10;data class CategoryEntity(&#10;    @PrimaryKey val categoryId: String,&#10;    val categoryName: String,&#10;    val parentId: String,&#10;    val type: String, // &quot;live&quot;, &quot;vod&quot;, or &quot;series&quot;&#10;    val orderIndex: Int = 0 // Preserve provider's order&#10;)&#10;&#10;@Entity(tableName = &quot;cache_metadata&quot;)&#10;data class CacheMetadata(&#10;    @PrimaryKey val key: String,&#10;    val lastUpdated: Long&#10;)&#10;&#10;@Entity(tableName = &quot;favorite_channels&quot;)&#10;data class FavoriteChannelEntity(&#10;    @PrimaryKey val channelId: String,&#10;    val timestamp: Long&#10;)&#10;&#10;@Entity(tableName = &quot;recent_channels&quot;)&#10;data class RecentChannelEntity(&#10;    @PrimaryKey(autoGenerate = true) val id: Int = 0,&#10;    val channelId: String,&#10;    val timestamp: Long&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/data/db/PlayxyDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/data/db/PlayxyDatabase.kt" />
              <option name="originalContent" value="package com.iptv.playxy.data.db&#10;&#10;import androidx.room.Database&#10;import androidx.room.RoomDatabase&#10;import androidx.room.TypeConverters&#10;&#10;@Database(&#10;    entities = [&#10;        UserProfileEntity::class,&#10;        LiveStreamEntity::class,&#10;        VodStreamEntity::class,&#10;        SeriesEntity::class,&#10;        CategoryEntity::class,&#10;        CacheMetadata::class,&#10;        FavoriteChannelEntity::class,&#10;        RecentChannelEntity::class&#10;    ],&#10;    version = 3,&#10;    exportSchema = false&#10;)&#10;@TypeConverters(Converters::class)&#10;abstract class PlayxyDatabase : RoomDatabase() {&#10;    abstract fun userProfileDao(): UserProfileDao&#10;    abstract fun liveStreamDao(): LiveStreamDao&#10;    abstract fun vodStreamDao(): VodStreamDao&#10;    abstract fun seriesDao(): SeriesDao&#10;    abstract fun categoryDao(): CategoryDao&#10;    abstract fun cacheMetadataDao(): CacheMetadataDao&#10;    abstract fun favoriteChannelDao(): FavoriteChannelDao&#10;    abstract fun recentChannelDao(): RecentChannelDao&#10;}&#10;" />
              <option name="updatedContent" value="package com.iptv.playxy.data.db&#10;&#10;import androidx.room.Database&#10;import androidx.room.RoomDatabase&#10;import androidx.room.TypeConverters&#10;&#10;@Database(&#10;    entities = [&#10;        UserProfileEntity::class,&#10;        LiveStreamEntity::class,&#10;        VodStreamEntity::class,&#10;        SeriesEntity::class,&#10;        CategoryEntity::class,&#10;        CacheMetadata::class,&#10;        FavoriteChannelEntity::class,&#10;        RecentChannelEntity::class&#10;    ],&#10;    version = 4,&#10;    exportSchema = false&#10;)&#10;@TypeConverters(Converters::class)&#10;abstract class PlayxyDatabase : RoomDatabase() {&#10;    abstract fun userProfileDao(): UserProfileDao&#10;    abstract fun liveStreamDao(): LiveStreamDao&#10;    abstract fun vodStreamDao(): VodStreamDao&#10;    abstract fun seriesDao(): SeriesDao&#10;    abstract fun categoryDao(): CategoryDao&#10;    abstract fun cacheMetadataDao(): CacheMetadataDao&#10;    abstract fun favoriteChannelDao(): FavoriteChannelDao&#10;    abstract fun recentChannelDao(): RecentChannelDao&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/domain/Category.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/domain/Category.kt" />
              <option name="originalContent" value="package com.iptv.playxy.domain&#10;&#10;data class Category(&#10;    val categoryId: String,&#10;    val categoryName: String,&#10;    val parentId: String&#10;)&#10;" />
              <option name="updatedContent" value="package com.iptv.playxy.domain&#10;&#10;data class Category(&#10;    val categoryId: String,&#10;    val categoryName: String,&#10;    val parentId: String,&#10;    val orderIndex: Int = 0&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/ui/tv/TVScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/ui/tv/TVScreen.kt" />
              <option name="originalContent" value="package com.iptv.playxy.ui.tv&#10;&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.hilt.lifecycle.viewmodel.compose.hiltViewModel&#10;import com.iptv.playxy.ui.player.FullscreenPlayerActivity&#10;import com.iptv.playxy.ui.tv.components.*&#10;import com.iptv.playxy.util.StreamUrlBuilder&#10;&#10;@Composable&#10;fun TVScreen(&#10;    viewModel: TVViewModel = hiltViewModel()&#10;) {&#10;    val context = LocalContext.current&#10;    val playerState by viewModel.playerState.collectAsState()&#10;    val currentChannel by viewModel.currentChannel.collectAsState()&#10;    val categories by viewModel.categories.collectAsState()&#10;    val selectedCategory by viewModel.selectedCategory.collectAsState()&#10;    val filteredChannels by viewModel.filteredChannels.collectAsState()&#10;    val userProfile by viewModel.userProfile.collectAsState()&#10;    val favoriteChannelIds by viewModel.favoriteChannelIds.collectAsState()&#10;&#10;    Column(modifier = Modifier.fillMaxSize()) {&#10;        // 1. Mini-Player (Only shown if currentChannel is not null)&#10;        val streamUrl = if (currentChannel != null &amp;&amp; userProfile != null) {&#10;            StreamUrlBuilder.buildLiveStreamUrl(userProfile, currentChannel)&#10;        } else {&#10;            &quot;&quot;&#10;        }&#10;&#10;        MiniPlayerView(&#10;            channel = currentChannel,&#10;            streamUrl = streamUrl,&#10;            state = playerState,&#10;            onClose = { viewModel.closePlayer() },&#10;            onPlayPause = { viewModel.togglePlayPause() },&#10;            onNext = { viewModel.playNextChannel() },&#10;            onPrev = { viewModel.playPreviousChannel() },&#10;            onFullscreen = {&#10;                currentChannel?.let { channel -&gt;&#10;                    userProfile?.let { profile -&gt;&#10;                        val fullscreenUrl = StreamUrlBuilder.buildLiveStreamUrl(profile, channel)&#10;                        val intent = FullscreenPlayerActivity.createIntent(&#10;                            context = context,&#10;                            streamUrl = fullscreenUrl,&#10;                            channelName = channel.name&#10;                        )&#10;                        context.startActivity(intent)&#10;                    }&#10;                }&#10;            }&#10;        )&#10;&#10;        // 2. Current Channel Info (Only shown if currentChannel is not null)&#10;        CurrentChannelInfoView(channel = currentChannel)&#10;&#10;        // 3. Category Chip Bar&#10;        CategoryChipBar(&#10;            categories = categories,&#10;            selected = selectedCategory,&#10;            onCategorySelected = { category -&gt;&#10;                viewModel.selectCategory(category)&#10;            }&#10;        )&#10;&#10;        // 4. Channel List (Scrollable, takes remaining space)&#10;        ChannelListView(&#10;            channels = filteredChannels,&#10;            favoriteChannelIds = favoriteChannelIds,&#10;            onChannelClick = { channel -&gt;&#10;                viewModel.playChannel(channel)&#10;            },&#10;            onFavoriteClick = { channel -&gt;&#10;                viewModel.toggleFavorite(channel)&#10;            },&#10;            modifier = Modifier.weight(1f)&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.iptv.playxy.ui.tv&#10;&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.hilt.lifecycle.viewmodel.compose.hiltViewModel&#10;import com.iptv.playxy.ui.player.FullscreenPlayerActivity&#10;import com.iptv.playxy.ui.tv.components.*&#10;import com.iptv.playxy.util.StreamUrlBuilder&#10;&#10;@Composable&#10;fun TVScreen(&#10;    viewModel: TVViewModel = hiltViewModel()&#10;) {&#10;    val context = LocalContext.current&#10;    val playerState by viewModel.playerState.collectAsState()&#10;    val currentChannel by viewModel.currentChannel.collectAsState()&#10;    val categories by viewModel.categories.collectAsState()&#10;    val selectedCategory by viewModel.selectedCategory.collectAsState()&#10;    val filteredChannels by viewModel.filteredChannels.collectAsState()&#10;    val userProfile by viewModel.userProfile.collectAsState()&#10;    val favoriteChannelIds by viewModel.favoriteChannelIds.collectAsState()&#10;&#10;    Column(modifier = Modifier.fillMaxSize()) {&#10;        // 1. Mini-Player (Only shown if currentChannel is not null)&#10;        val channel = currentChannel&#10;        val profile = userProfile&#10;        val streamUrl = if (channel != null &amp;&amp; profile != null) {&#10;            StreamUrlBuilder.buildLiveStreamUrl(profile, channel)&#10;        } else {&#10;            &quot;&quot;&#10;        }&#10;&#10;        MiniPlayerView(&#10;            channel = currentChannel,&#10;            streamUrl = streamUrl,&#10;            state = playerState,&#10;            onClose = { viewModel.closePlayer() },&#10;            onPlayPause = { viewModel.togglePlayPause() },&#10;            onNext = { viewModel.playNextChannel() },&#10;            onPrev = { viewModel.playPreviousChannel() },&#10;            onFullscreen = {&#10;                currentChannel?.let { channel -&gt;&#10;                    userProfile?.let { profile -&gt;&#10;                        val fullscreenUrl = StreamUrlBuilder.buildLiveStreamUrl(profile, channel)&#10;                        val intent = FullscreenPlayerActivity.createIntent(&#10;                            context = context,&#10;                            streamUrl = fullscreenUrl,&#10;                            channelName = channel.name&#10;                        )&#10;                        context.startActivity(intent)&#10;                    }&#10;                }&#10;            }&#10;        )&#10;&#10;        // 2. Current Channel Info (Only shown if currentChannel is not null)&#10;        CurrentChannelInfoView(channel = currentChannel)&#10;&#10;        // 3. Category Chip Bar&#10;        CategoryChipBar(&#10;            categories = categories,&#10;            selected = selectedCategory,&#10;            onCategorySelected = { category -&gt;&#10;                viewModel.selectCategory(category)&#10;            }&#10;        )&#10;&#10;        // 4. Channel List (Scrollable, takes remaining space)&#10;        ChannelListView(&#10;            channels = filteredChannels,&#10;            favoriteChannelIds = favoriteChannelIds,&#10;            onChannelClick = { channel -&gt;&#10;                viewModel.playChannel(channel)&#10;            },&#10;            onFavoriteClick = { channel -&gt;&#10;                viewModel.toggleFavorite(channel)&#10;            },&#10;            modifier = Modifier.weight(1f)&#10;        )&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/util/EntityMapper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/util/EntityMapper.kt" />
              <option name="originalContent" value="package com.iptv.playxy.util&#10;&#10;import com.iptv.playxy.data.db.*&#10;import com.iptv.playxy.domain.*&#10;&#10;/**&#10; * Mapper object to convert between database entities and domain models&#10; */&#10;object EntityMapper {&#10;    &#10;    // User Profile mappings&#10;    fun toEntity(profile: UserProfile): UserProfileEntity {&#10;        return UserProfileEntity(&#10;            id = profile.id,&#10;            profileName = profile.profileName,&#10;            username = profile.username,&#10;            password = profile.password,&#10;            url = profile.url,&#10;            lastUpdated = profile.lastUpdated,&#10;            isValid = profile.isValid&#10;        )&#10;    }&#10;    &#10;    fun toDomain(entity: UserProfileEntity): UserProfile {&#10;        return UserProfile(&#10;            id = entity.id,&#10;            profileName = entity.profileName,&#10;            username = entity.username,&#10;            password = entity.password,&#10;            url = entity.url,&#10;            lastUpdated = entity.lastUpdated,&#10;            isValid = entity.isValid&#10;        )&#10;    }&#10;    &#10;    // LiveStream mappings&#10;    fun toEntity(stream: LiveStream): LiveStreamEntity {&#10;        return LiveStreamEntity(&#10;            streamId = stream.streamId,&#10;            name = stream.name,&#10;            streamIcon = stream.streamIcon,&#10;            isAdult = stream.isAdult,&#10;            categoryId = stream.categoryId,&#10;            tvArchive = stream.tvArchive,&#10;            epgChannelId = stream.epgChannelId,&#10;            added = stream.added,&#10;            customSid = stream.customSid,&#10;            directSource = stream.directSource,&#10;            tvArchiveDuration = stream.tvArchiveDuration&#10;        )&#10;    }&#10;    &#10;    fun liveStreamToDomain(entity: LiveStreamEntity): LiveStream {&#10;        return LiveStream(&#10;            streamId = entity.streamId,&#10;            name = entity.name,&#10;            streamIcon = entity.streamIcon,&#10;            isAdult = entity.isAdult,&#10;            categoryId = entity.categoryId,&#10;            tvArchive = entity.tvArchive,&#10;            epgChannelId = entity.epgChannelId,&#10;            added = entity.added,&#10;            customSid = entity.customSid,&#10;            directSource = entity.directSource,&#10;            tvArchiveDuration = entity.tvArchiveDuration&#10;        )&#10;    }&#10;    &#10;    // VodStream mappings&#10;    fun toEntity(stream: VodStream): VodStreamEntity {&#10;        return VodStreamEntity(&#10;            streamId = stream.streamId,&#10;            name = stream.name,&#10;            streamIcon = stream.streamIcon,&#10;            tmdbId = stream.tmdbId,&#10;            rating = stream.rating,&#10;            rating5Based = stream.rating5Based,&#10;            containerExtension = stream.containerExtension,&#10;            added = stream.added,&#10;            isAdult = stream.isAdult,&#10;            categoryId = stream.categoryId,&#10;            customSid = stream.customSid,&#10;            directSource = stream.directSource&#10;        )&#10;    }&#10;    &#10;    fun vodStreamToDomain(entity: VodStreamEntity): VodStream {&#10;        return VodStream(&#10;            streamId = entity.streamId,&#10;            name = entity.name,&#10;            streamIcon = entity.streamIcon,&#10;            tmdbId = entity.tmdbId,&#10;            rating = entity.rating,&#10;            rating5Based = entity.rating5Based,&#10;            containerExtension = entity.containerExtension,&#10;            added = entity.added,&#10;            isAdult = entity.isAdult,&#10;            categoryId = entity.categoryId,&#10;            customSid = entity.customSid,&#10;            directSource = entity.directSource&#10;        )&#10;    }&#10;    &#10;    // Series mappings&#10;    fun toEntity(series: Series): SeriesEntity {&#10;        return SeriesEntity(&#10;            seriesId = series.seriesId,&#10;            name = series.name,&#10;            cover = series.cover,&#10;            plot = series.plot,&#10;            cast = series.cast,&#10;            director = series.director,&#10;            genre = series.genre,&#10;            releaseDate = series.releaseDate,&#10;            rating = series.rating,&#10;            rating5Based = series.rating5Based,&#10;            backdropPath = Converters().fromStringList(series.backdropPath),&#10;            youtubeTrailer = series.youtubeTrailer,&#10;            episodeRunTime = series.episodeRunTime,&#10;            categoryId = series.categoryId,&#10;            tmdbId = series.tmdbId,&#10;            lastModified = series.lastModified&#10;        )&#10;    }&#10;    &#10;    fun seriesToDomain(entity: SeriesEntity): Series {&#10;        return Series(&#10;            seriesId = entity.seriesId,&#10;            name = entity.name,&#10;            cover = entity.cover,&#10;            plot = entity.plot,&#10;            cast = entity.cast,&#10;            director = entity.director,&#10;            genre = entity.genre,&#10;            releaseDate = entity.releaseDate,&#10;            rating = entity.rating,&#10;            rating5Based = entity.rating5Based,&#10;            backdropPath = Converters().toStringList(entity.backdropPath),&#10;            youtubeTrailer = entity.youtubeTrailer,&#10;            episodeRunTime = entity.episodeRunTime,&#10;            categoryId = entity.categoryId,&#10;            tmdbId = entity.tmdbId,&#10;            lastModified = entity.lastModified&#10;        )&#10;    }&#10;    &#10;    // Category mappings&#10;    fun toEntity(category: Category, type: String): CategoryEntity {&#10;        return CategoryEntity(&#10;            categoryId = category.categoryId,&#10;            categoryName = category.categoryName,&#10;            parentId = category.parentId,&#10;            type = type&#10;        )&#10;    }&#10;    &#10;    fun categoryToDomain(entity: CategoryEntity): Category {&#10;        return Category(&#10;            categoryId = entity.categoryId,&#10;            categoryName = entity.categoryName,&#10;            parentId = entity.parentId&#10;        )&#10;    }&#10;    &#10;    // FavoriteChannel mappings&#10;    fun toEntity(favorite: FavoriteChannel): FavoriteChannelEntity {&#10;        return FavoriteChannelEntity(&#10;            channelId = favorite.channelId,&#10;            timestamp = favorite.timestamp&#10;        )&#10;    }&#10;    &#10;    fun favoriteChannelToDomain(entity: FavoriteChannelEntity): FavoriteChannel {&#10;        return FavoriteChannel(&#10;            channelId = entity.channelId,&#10;            timestamp = entity.timestamp&#10;        )&#10;    }&#10;    &#10;    // RecentChannel mappings&#10;    fun toEntity(recent: RecentChannel, id: Int = 0): RecentChannelEntity {&#10;        return RecentChannelEntity(&#10;            id = id,&#10;            channelId = recent.channelId,&#10;            timestamp = recent.timestamp&#10;        )&#10;    }&#10;    &#10;    fun recentChannelToDomain(entity: RecentChannelEntity): RecentChannel {&#10;        return RecentChannel(&#10;            channelId = entity.channelId,&#10;            timestamp = entity.timestamp&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.iptv.playxy.util&#10;&#10;import com.iptv.playxy.data.db.*&#10;import com.iptv.playxy.domain.*&#10;&#10;/**&#10; * Mapper object to convert between database entities and domain models&#10; */&#10;object EntityMapper {&#10;    &#10;    // User Profile mappings&#10;    fun toEntity(profile: UserProfile): UserProfileEntity {&#10;        return UserProfileEntity(&#10;            id = profile.id,&#10;            profileName = profile.profileName,&#10;            username = profile.username,&#10;            password = profile.password,&#10;            url = profile.url,&#10;            lastUpdated = profile.lastUpdated,&#10;            isValid = profile.isValid&#10;        )&#10;    }&#10;    &#10;    fun toDomain(entity: UserProfileEntity): UserProfile {&#10;        return UserProfile(&#10;            id = entity.id,&#10;            profileName = entity.profileName,&#10;            username = entity.username,&#10;            password = entity.password,&#10;            url = entity.url,&#10;            lastUpdated = entity.lastUpdated,&#10;            isValid = entity.isValid&#10;        )&#10;    }&#10;    &#10;    // LiveStream mappings&#10;    fun toEntity(stream: LiveStream): LiveStreamEntity {&#10;        return LiveStreamEntity(&#10;            streamId = stream.streamId,&#10;            name = stream.name,&#10;            streamIcon = stream.streamIcon,&#10;            isAdult = stream.isAdult,&#10;            categoryId = stream.categoryId,&#10;            tvArchive = stream.tvArchive,&#10;            epgChannelId = stream.epgChannelId,&#10;            added = stream.added,&#10;            customSid = stream.customSid,&#10;            directSource = stream.directSource,&#10;            tvArchiveDuration = stream.tvArchiveDuration&#10;        )&#10;    }&#10;    &#10;    fun liveStreamToDomain(entity: LiveStreamEntity): LiveStream {&#10;        return LiveStream(&#10;            streamId = entity.streamId,&#10;            name = entity.name,&#10;            streamIcon = entity.streamIcon,&#10;            isAdult = entity.isAdult,&#10;            categoryId = entity.categoryId,&#10;            tvArchive = entity.tvArchive,&#10;            epgChannelId = entity.epgChannelId,&#10;            added = entity.added,&#10;            customSid = entity.customSid,&#10;            directSource = entity.directSource,&#10;            tvArchiveDuration = entity.tvArchiveDuration&#10;        )&#10;    }&#10;    &#10;    // VodStream mappings&#10;    fun toEntity(stream: VodStream): VodStreamEntity {&#10;        return VodStreamEntity(&#10;            streamId = stream.streamId,&#10;            name = stream.name,&#10;            streamIcon = stream.streamIcon,&#10;            tmdbId = stream.tmdbId,&#10;            rating = stream.rating,&#10;            rating5Based = stream.rating5Based,&#10;            containerExtension = stream.containerExtension,&#10;            added = stream.added,&#10;            isAdult = stream.isAdult,&#10;            categoryId = stream.categoryId,&#10;            customSid = stream.customSid,&#10;            directSource = stream.directSource&#10;        )&#10;    }&#10;    &#10;    fun vodStreamToDomain(entity: VodStreamEntity): VodStream {&#10;        return VodStream(&#10;            streamId = entity.streamId,&#10;            name = entity.name,&#10;            streamIcon = entity.streamIcon,&#10;            tmdbId = entity.tmdbId,&#10;            rating = entity.rating,&#10;            rating5Based = entity.rating5Based,&#10;            containerExtension = entity.containerExtension,&#10;            added = entity.added,&#10;            isAdult = entity.isAdult,&#10;            categoryId = entity.categoryId,&#10;            customSid = entity.customSid,&#10;            directSource = entity.directSource&#10;        )&#10;    }&#10;    &#10;    // Series mappings&#10;    fun toEntity(series: Series): SeriesEntity {&#10;        return SeriesEntity(&#10;            seriesId = series.seriesId,&#10;            name = series.name,&#10;            cover = series.cover,&#10;            plot = series.plot,&#10;            cast = series.cast,&#10;            director = series.director,&#10;            genre = series.genre,&#10;            releaseDate = series.releaseDate,&#10;            rating = series.rating,&#10;            rating5Based = series.rating5Based,&#10;            backdropPath = Converters().fromStringList(series.backdropPath),&#10;            youtubeTrailer = series.youtubeTrailer,&#10;            episodeRunTime = series.episodeRunTime,&#10;            categoryId = series.categoryId,&#10;            tmdbId = series.tmdbId,&#10;            lastModified = series.lastModified&#10;        )&#10;    }&#10;    &#10;    fun seriesToDomain(entity: SeriesEntity): Series {&#10;        return Series(&#10;            seriesId = entity.seriesId,&#10;            name = entity.name,&#10;            cover = entity.cover,&#10;            plot = entity.plot,&#10;            cast = entity.cast,&#10;            director = entity.director,&#10;            genre = entity.genre,&#10;            releaseDate = entity.releaseDate,&#10;            rating = entity.rating,&#10;            rating5Based = entity.rating5Based,&#10;            backdropPath = Converters().toStringList(entity.backdropPath),&#10;            youtubeTrailer = entity.youtubeTrailer,&#10;            episodeRunTime = entity.episodeRunTime,&#10;            categoryId = entity.categoryId,&#10;            tmdbId = entity.tmdbId,&#10;            lastModified = entity.lastModified&#10;        )&#10;    }&#10;    &#10;    // Category mappings&#10;    fun toEntity(category: Category, type: String): CategoryEntity {&#10;        return CategoryEntity(&#10;            categoryId = category.categoryId,&#10;            categoryName = category.categoryName,&#10;            parentId = category.parentId,&#10;            type = type,&#10;            orderIndex = category.orderIndex&#10;        )&#10;    }&#10;    &#10;    fun categoryToDomain(entity: CategoryEntity): Category {&#10;        return Category(&#10;            categoryId = entity.categoryId,&#10;            categoryName = entity.categoryName,&#10;            parentId = entity.parentId,&#10;            orderIndex = entity.orderIndex&#10;        )&#10;    }&#10;    &#10;    // FavoriteChannel mappings&#10;    fun toEntity(favorite: FavoriteChannel): FavoriteChannelEntity {&#10;        return FavoriteChannelEntity(&#10;            channelId = favorite.channelId,&#10;            timestamp = favorite.timestamp&#10;        )&#10;    }&#10;    &#10;    fun favoriteChannelToDomain(entity: FavoriteChannelEntity): FavoriteChannel {&#10;        return FavoriteChannel(&#10;            channelId = entity.channelId,&#10;            timestamp = entity.timestamp&#10;        )&#10;    }&#10;    &#10;    // RecentChannel mappings&#10;    fun toEntity(recent: RecentChannel, id: Int = 0): RecentChannelEntity {&#10;        return RecentChannelEntity(&#10;            id = id,&#10;            channelId = recent.channelId,&#10;            timestamp = recent.timestamp&#10;        )&#10;    }&#10;    &#10;    fun recentChannelToDomain(entity: RecentChannelEntity): RecentChannel {&#10;        return RecentChannel(&#10;            channelId = entity.channelId,&#10;            timestamp = entity.timestamp&#10;        )&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/util/ResponseMapper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/util/ResponseMapper.kt" />
              <option name="originalContent" value="package com.iptv.playxy.util&#10;&#10;import com.iptv.playxy.data.api.CategoryResponse&#10;import com.iptv.playxy.data.api.LiveStreamResponse&#10;import com.iptv.playxy.data.api.SeriesResponse&#10;import com.iptv.playxy.data.api.VodStreamResponse&#10;import com.iptv.playxy.domain.Category&#10;import com.iptv.playxy.domain.LiveStream&#10;import com.iptv.playxy.domain.Series&#10;import com.iptv.playxy.domain.VodStream&#10;&#10;/**&#10; * Mapper object to convert API response models to domain models&#10; * Handles all type conversions and null safety&#10; */&#10;object ResponseMapper {&#10;    &#10;    fun toLiveStream(response: LiveStreamResponse): LiveStream {&#10;        return LiveStream(&#10;            streamId = response.streamId.orEmpty(),&#10;            name = response.name.orEmpty(),&#10;            streamIcon = response.streamIcon,&#10;            isAdult = response.isAdult?.let { it == &quot;1&quot; || it.equals(&quot;true&quot;, ignoreCase = true) } ?: false,&#10;            categoryId = response.categoryId.orEmpty(),&#10;            tvArchive = response.tvArchive?.let { it == &quot;1&quot; || it.equals(&quot;true&quot;, ignoreCase = true) } ?: false,&#10;            epgChannelId = response.epgChannelId,&#10;            added = response.added,&#10;            customSid = response.customSid,&#10;            directSource = response.directSource,&#10;            tvArchiveDuration = response.tvArchiveDuration?.toIntOrNull() ?: 0&#10;        )&#10;    }&#10;    &#10;    fun toVodStream(response: VodStreamResponse): VodStream {&#10;        return VodStream(&#10;            streamId = response.streamId.orEmpty(),&#10;            name = response.name.orEmpty(),&#10;            streamIcon = response.streamIcon,&#10;            tmdbId = response.tmdbId,&#10;            rating = response.rating?.toFloatOrNull() ?: 0f,&#10;            rating5Based = response.rating5Based?.toFloatOrNull() ?: 0f,&#10;            containerExtension = response.containerExtension.orEmpty(),&#10;            added = response.added,&#10;            isAdult = response.isAdult?.let { it == &quot;1&quot; || it.equals(&quot;true&quot;, ignoreCase = true) } ?: false,&#10;            categoryId = response.categoryId.orEmpty(),&#10;            customSid = response.customSid,&#10;            directSource = response.directSource&#10;        )&#10;    }&#10;    &#10;    fun toSeries(response: SeriesResponse): Series {&#10;        return Series(&#10;            seriesId = response.seriesId.orEmpty(),&#10;            name = response.name.orEmpty(),&#10;            cover = response.cover,&#10;            plot = response.plot,&#10;            cast = response.cast,&#10;            director = response.director,&#10;            genre = response.genre,&#10;            releaseDate = response.releaseDate,&#10;            rating = response.rating?.toFloatOrNull() ?: 0f,&#10;            rating5Based = response.rating5Based?.toFloatOrNull() ?: 0f,&#10;            backdropPath = response.backdropPath ?: emptyList(),&#10;            youtubeTrailer = response.youtubeTrailer,&#10;            episodeRunTime = response.episodeRunTime,&#10;            categoryId = response.categoryId.orEmpty(),&#10;            tmdbId = response.tmdbId,&#10;            lastModified = response.lastModified&#10;        )&#10;    }&#10;    &#10;    fun toCategory(response: CategoryResponse): Category {&#10;        return Category(&#10;            categoryId = response.categoryId.orEmpty(),&#10;            categoryName = response.categoryName.orEmpty(),&#10;            parentId = response.parentId.orEmpty()&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.iptv.playxy.util&#10;&#10;import com.iptv.playxy.data.api.CategoryResponse&#10;import com.iptv.playxy.data.api.LiveStreamResponse&#10;import com.iptv.playxy.data.api.SeriesResponse&#10;import com.iptv.playxy.data.api.VodStreamResponse&#10;import com.iptv.playxy.domain.Category&#10;import com.iptv.playxy.domain.LiveStream&#10;import com.iptv.playxy.domain.Series&#10;import com.iptv.playxy.domain.VodStream&#10;&#10;/**&#10; * Mapper object to convert API response models to domain models&#10; * Handles all type conversions and null safety&#10; */&#10;object ResponseMapper {&#10;    &#10;    fun toLiveStream(response: LiveStreamResponse): LiveStream {&#10;        return LiveStream(&#10;            streamId = response.streamId.orEmpty(),&#10;            name = response.name.orEmpty(),&#10;            streamIcon = response.streamIcon,&#10;            isAdult = response.isAdult?.let { it == &quot;1&quot; || it.equals(&quot;true&quot;, ignoreCase = true) } ?: false,&#10;            categoryId = response.categoryId.orEmpty(),&#10;            tvArchive = response.tvArchive?.let { it == &quot;1&quot; || it.equals(&quot;true&quot;, ignoreCase = true) } ?: false,&#10;            epgChannelId = response.epgChannelId,&#10;            added = response.added,&#10;            customSid = response.customSid,&#10;            directSource = response.directSource,&#10;            tvArchiveDuration = response.tvArchiveDuration?.toIntOrNull() ?: 0&#10;        )&#10;    }&#10;    &#10;    fun toVodStream(response: VodStreamResponse): VodStream {&#10;        return VodStream(&#10;            streamId = response.streamId.orEmpty(),&#10;            name = response.name.orEmpty(),&#10;            streamIcon = response.streamIcon,&#10;            tmdbId = response.tmdbId,&#10;            rating = response.rating?.toFloatOrNull() ?: 0f,&#10;            rating5Based = response.rating5Based?.toFloatOrNull() ?: 0f,&#10;            containerExtension = response.containerExtension.orEmpty(),&#10;            added = response.added,&#10;            isAdult = response.isAdult?.let { it == &quot;1&quot; || it.equals(&quot;true&quot;, ignoreCase = true) } ?: false,&#10;            categoryId = response.categoryId.orEmpty(),&#10;            customSid = response.customSid,&#10;            directSource = response.directSource&#10;        )&#10;    }&#10;    &#10;    fun toSeries(response: SeriesResponse): Series {&#10;        return Series(&#10;            seriesId = response.seriesId.orEmpty(),&#10;            name = response.name.orEmpty(),&#10;            cover = response.cover,&#10;            plot = response.plot,&#10;            cast = response.cast,&#10;            director = response.director,&#10;            genre = response.genre,&#10;            releaseDate = response.releaseDate,&#10;            rating = response.rating?.toFloatOrNull() ?: 0f,&#10;            rating5Based = response.rating5Based?.toFloatOrNull() ?: 0f,&#10;            backdropPath = response.backdropPath ?: emptyList(),&#10;            youtubeTrailer = response.youtubeTrailer,&#10;            episodeRunTime = response.episodeRunTime,&#10;            categoryId = response.categoryId.orEmpty(),&#10;            tmdbId = response.tmdbId,&#10;            lastModified = response.lastModified&#10;        )&#10;    }&#10;    &#10;    fun toCategory(response: CategoryResponse, orderIndex: Int = 0): Category {&#10;        return Category(&#10;            categoryId = response.categoryId.orEmpty(),&#10;            categoryName = response.categoryName.orEmpty(),&#10;            parentId = response.parentId.orEmpty(),&#10;            orderIndex = orderIndex&#10;        )&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/util/StreamUrlBuilder.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/iptv/playxy/util/StreamUrlBuilder.kt" />
              <option name="updatedContent" value="package com.iptv.playxy.util&#10;&#10;import com.iptv.playxy.domain.LiveStream&#10;import com.iptv.playxy.domain.UserProfile&#10;import com.iptv.playxy.domain.VodStream&#10;&#10;object StreamUrlBuilder {&#10;    &#10;    /**&#10;     * Build the streaming URL for a live channel&#10;     * Format: http://url:port/live/username/password/stream_id.ext&#10;     */&#10;    fun buildLiveStreamUrl(profile: UserProfile, stream: LiveStream, extension: String = &quot;ts&quot;): String {&#10;        // If directSource is provided, use it&#10;        if (!stream.directSource.isNullOrEmpty()) {&#10;            return stream.directSource&#10;        }&#10;        &#10;        // Build URL from profile and stream ID&#10;        val baseUrl = profile.url.trimEnd('/')&#10;        return &quot;$baseUrl/live/${profile.username}/${profile.password}/${stream.streamId}.$extension&quot;&#10;    }&#10;    &#10;    /**&#10;     * Build the streaming URL for a VOD stream&#10;     * Format: http://url:port/movie/username/password/stream_id.ext&#10;     */&#10;    fun buildVodStreamUrl(profile: UserProfile, stream: VodStream): String {&#10;        // If directSource is provided, use it&#10;        if (!stream.directSource.isNullOrEmpty()) {&#10;            return stream.directSource&#10;        }&#10;        &#10;        // Build URL from profile and stream ID&#10;        val baseUrl = profile.url.trimEnd('/')&#10;        val extension = stream.containerExtension.ifEmpty { &quot;mp4&quot; }&#10;        return &quot;$baseUrl/movie/${profile.username}/${profile.password}/${stream.streamId}.$extension&quot;&#10;    }&#10;    &#10;    /**&#10;     * Build the streaming URL for series episode&#10;     * Format: http://url:port/series/username/password/stream_id.ext&#10;     */&#10;    fun buildSeriesStreamUrl(profile: UserProfile, streamId: String, extension: String = &quot;mp4&quot;): String {&#10;        val baseUrl = profile.url.trimEnd('/')&#10;        return &quot;$baseUrl/series/${profile.username}/${profile.password}/$streamId.$extension&quot;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>